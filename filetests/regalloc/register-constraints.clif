test regalloc
target x86_64

; test against a regression where using eight general-purpose registers over the
; end of a basic block could ignore a diversion and result in a miscompile.
function u0:11(i64 vmctx) -> i32 system_v {
    gv0 = vmctx
    gv1 = load.i64 notrap aligned gv0-8
    heap0 = static gv0, min 0x0002_0000, bound 0x0040_0000, offset_guard 0x0040_0000, index_type i32
    sig0 = (i64 vmctx, i32) system_v
    fn0 = colocated u0:10 sig0

    ebb0(v0: i64):
        v6 = iconst.i32 0
        v10 = iadd v6, v6
        v11 = iconst.i32 0
        v12 = iconst.i32 0
        v15 = iconst.i32 0
        v18 = iconst.i32 0
        v19 = heap_addr.i64 heap0, v6, 1
        istore8 v18, v6+31
        v23 = iconst.i64 0
        store v15, v23
        store v12, v23
        store v11, v23
        call fn0(v0, v10)
        return v6
}

; test against an error where variable arguments were checked for constraints incorrectly
; resulting in a regalloc panic.
function u0:0(i64, i64, i64) -> i64 system_v {
    sig0 = (i64) system_v
    sig1 = () system_v
    fn0 = u0:28 sig0

     ebb0(v0: i64, v1: i64, v2: i64):
         v27 = iconst.i32 0
         brz v27, ebb5
         jump ebb1

     ebb1:
         trap user0

     ebb5:
         v49 = iconst.i32 0
         brz v49, ebb8
         jump ebb6

     ebb6:
         trap user0

     ebb8:
         v65 = iconst.i32 0
         brz v65, ebb10
         jump ebb9

     ebb9:
         trap user0

     ebb10:
         v69 = iconst.i64 0
         call fn0(v69)
         call_indirect.i64 sig1, v0()
              jump ebb11

     ebb11:
         trap user0
}
